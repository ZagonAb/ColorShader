    /*Rectangle {
        id: imagesScreenshots
        color: "transparent"
        width: parent.width
        height: parent.height
        z: 1001

        Image {
            id: screenshotImage1
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage1.width
                    duration: 5000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage1.width
                    to: 0
                    duration: 5000
                }
            }
        }

        Image {
            id: screenshotImage2
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage2.width
                    duration: 10000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage2.width
                    to: 0
                    duration: 10000
                }
            }
        }

        Image {
            id: gameLogo1
            width: parent.width * 0.5
            height: width * 0.5
            anchors {
                right: parent.right
                bottom: parent.bottom
                margins: 20
            }
            fillMode: Image.PreserveAspectFit
            opacity: screensaverActive ? 1 : 0
            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }
        }
    }*/

    /*Rectangle {
        id: imagesScreenshots
        color: "transparent"
        width: parent.width
        height: parent.height
        z: 1001

        // Imágenes del screensaver
        Image {
            id: screenshotImage1
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage1.width
                    duration: 5000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage1.width
                    to: 0
                    duration: 5000
                }
            }
        }

        Image {
            id: screenshotImage2
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage2.width
                    duration: 10000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage2.width
                    to: 0
                    duration: 10000
                }
            }
        }

        // Efecto CRT (ShaderEffect)
        ShaderEffect {
            id: crtEffect
            anchors.fill: parent
            opacity: screensaverActive ? 1 : 0 // Semi-transparente cuando el screensaver está activo
            visible: screensaverActive // Solo visible cuando el screensaver está activo

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            // Propiedades del shader
            property real time: 0 // Puedes animar esto para un efecto más dinámico
            property variant source: null // No necesitamos una fuente, ya que es un efecto de superposición

            // Vertex shader (no necesario modificarlo para este efecto)
            vertexShader: "
            uniform highp mat4 qt_Matrix;
            attribute highp vec4 qt_Vertex;
            attribute highp vec2 qt_MultiTexCoord0;
            varying highp vec2 coord;
            void main() {
            coord = qt_MultiTexCoord0;
            gl_Position = qt_Matrix * qt_Vertex;
        }"

        // Fragment shader para el efecto de scanlines
        fragmentShader: "
        varying highp vec2 coord;
        uniform lowp float qt_Opacity;
        void main() {
        // Efecto de líneas de escaneo (scanlines)
        highp float scanline = mod(coord.y * 400.0, 2.0);
        scanline = clamp(scanline, 0.5, 1.0); // Hacemos las líneas semi-transparentes

        // Color final con el efecto de scanlines
        gl_FragColor = vec4(0.0, 0.0, 0.0, (1.0 - scanline) * 0.5) * qt_Opacity;
        }"
        }

        // Logo del juego
        Image {
            id: gameLogo1
            width: parent.width * 0.5
            height: width * 0.5
            anchors {
                right: parent.right
                bottom: parent.bottom
                margins: 20
            }
            fillMode: Image.PreserveAspectFit
            opacity: screensaverActive ? 1 : 0
            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }
        }
    }*/


    /*Rectangle {
        id: imagesScreenshots
        color: "transparent"
        width: parent.width
        height: parent.height
        z: 1001

        // Propiedad para controlar la intensidad del Glow
        property real glowIntensity: 0.3 // Valor entre 0 y 1

        // Imágenes del screensaver
        Image {
            id: screenshotImage1
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage1.width
                    duration: 5000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage1.width
                    to: 0
                    duration: 5000
                }
            }

            // Efecto Glow para screenshotImage1
            ShaderEffect {
                id: glowEffect1
                anchors.fill: parent
                opacity: screensaverActive ? 1 : 0 // Visible cuando el screensaver está activo
                visible: screensaverActive && showImage1 // Solo visible si es la imagen actual

                // Propiedades del shader
                property variant source: parent // Usamos la imagen padre como fuente
                property real glowIntensity: imagesScreenshots.glowIntensity // Intensidad del Glow

                // Vertex shader (no necesario modificarlo para este efecto)
                vertexShader: "
                uniform highp mat4 qt_Matrix;
                attribute highp vec4 qt_Vertex;
                attribute highp vec2 qt_MultiTexCoord0;
                varying highp vec2 coord;
                void main() {
                coord = qt_MultiTexCoord0;
                gl_Position = qt_Matrix * qt_Vertex;
            }"

            // Fragment shader para el efecto de scanlines, desenfoque gaussiano y Glow
            fragmentShader: "
            varying highp vec2 coord;
            uniform lowp float qt_Opacity;
            uniform lowp float glowIntensity;
            uniform sampler2D source;

            // Función para calcular el brillo de un color
            highp float luminance(highp vec3 color) {
            return dot(color, vec3(0.2126, 0.7152, 0.0722));
            }

            // Función para aplicar un desenfoque gaussiano simple
            highp vec4 blur(highp vec2 uv) {
            highp vec2 texelSize = vec2(1.0 / 800.0, 1.0 / 600.0); // Ajusta según la resolución
            highp vec4 color = vec4(0.0);
            highp float totalWeight = 0.0;

            for (int x = -2; x <= 2; x++) {
                for (int y = -2; y <= 2; y++) {
                    highp float weight = exp(-float(x * x + y * y) / 2.0);
                    color += texture2D(source, uv + vec2(x, y) * texelSize) * weight;
                    totalWeight += weight;
            }
            }

            return color / totalWeight;
            }

            void main() {
            // Obtener el color de la imagen original
            highp vec4 originalColor = texture2D(source, coord);

            // Efecto de líneas de escaneo (scanlines)
            highp float scanline = mod(coord.y * 400.0, 2.0);
            scanline = clamp(scanline, 0.5, 1.0); // Hacemos las líneas semi-transparentes

            // Aplicar el efecto de scanlines al color original
            highp vec4 crtColor = originalColor * scanline;

            // Aplicar el efecto Glow con desenfoque gaussiano
            highp vec4 blurredColor = blur(coord);
            highp float brightness = luminance(originalColor.rgb);
            highp vec4 glowColor = blurredColor * brightness * glowIntensity * 2.0; // Aumentamos la intensidad

            // Combinar el efecto CRT con el Glow
            highp vec4 finalColor = crtColor + glowColor;

            // Ajustar la opacidad final
            gl_FragColor = finalColor * qt_Opacity;
            }"
            }
        }

        Image {
            id: screenshotImage2
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage2.width
                    duration: 10000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage2.width
                    to: 0
                    duration: 10000
                }
            }

            // Efecto Glow para screenshotImage2
            ShaderEffect {
                id: glowEffect2
                anchors.fill: parent
                opacity: screensaverActive ? 1 : 0 // Visible cuando el screensaver está activo
                visible: screensaverActive && !showImage1 // Solo visible si es la imagen actual

                // Propiedades del shader
                property variant source: parent // Usamos la imagen padre como fuente
                property real glowIntensity: imagesScreenshots.glowIntensity // Intensidad del Glow

                // Vertex shader (no necesario modificarlo para este efecto)
                vertexShader: "
                uniform highp mat4 qt_Matrix;
                attribute highp vec4 qt_Vertex;
                attribute highp vec2 qt_MultiTexCoord0;
                varying highp vec2 coord;
                void main() {
                coord = qt_MultiTexCoord0;
                gl_Position = qt_Matrix * qt_Vertex;
            }"

            // Fragment shader para el efecto de scanlines, desenfoque gaussiano y Glow
            fragmentShader: "
            varying highp vec2 coord;
            uniform lowp float qt_Opacity;
            uniform lowp float glowIntensity;
            uniform sampler2D source;

            // Función para calcular el brillo de un color
            highp float luminance(highp vec3 color) {
            return dot(color, vec3(0.2126, 0.7152, 0.0722));
            }

            // Función para aplicar un desenfoque gaussiano simple
            highp vec4 blur(highp vec2 uv) {
            highp vec2 texelSize = vec2(1.0 / 800.0, 1.0 / 600.0); // Ajusta según la resolución
            highp vec4 color = vec4(0.0);
            highp float totalWeight = 0.0;

            for (int x = -2; x <= 2; x++) {
                for (int y = -2; y <= 2; y++) {
                    highp float weight = exp(-float(x * x + y * y) / 2.0);
                    color += texture2D(source, uv + vec2(x, y) * texelSize) * weight;
                    totalWeight += weight;
            }
            }

            return color / totalWeight;
            }

            void main() {
            // Obtener el color de la imagen original
            highp vec4 originalColor = texture2D(source, coord);

            // Efecto de líneas de escaneo (scanlines)
            highp float scanline = mod(coord.y * 400.0, 2.0);
            scanline = clamp(scanline, 0.5, 1.0); // Hacemos las líneas semi-transparentes

            // Aplicar el efecto de scanlines al color original
            highp vec4 crtColor = originalColor * scanline;

            // Aplicar el efecto Glow con desenfoque gaussiano
            highp vec4 blurredColor = blur(coord);
            highp float brightness = luminance(originalColor.rgb);
            highp vec4 glowColor = blurredColor * brightness * glowIntensity * 2.0; // Aumentamos la intensidad

            // Combinar el efecto CRT con el Glow
            highp vec4 finalColor = crtColor + glowColor;

            // Ajustar la opacidad final
            gl_FragColor = finalColor * qt_Opacity;
            }"
            }
        }

        // Logo del juego
        Image {
            id: gameLogo1
            width: parent.width * 0.5
            height: width * 0.5
            anchors {
                right: parent.right
                bottom: parent.bottom
                margins: 20
            }
            fillMode: Image.PreserveAspectFit
            opacity: screensaverActive ? 1 : 0
            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }
        }
    }*/


    /*Rectangle {
        id: imagesScreenshots
        color: "transparent"
        width: parent.width
        height: parent.height
        z: 1001

        // Imágenes del screensaver
        Image {
            id: screenshotImage1
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage1.width
                    duration: 5000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage1.width
                    to: 0
                    duration: 5000
                }
            }
        }

        Image {
            id: screenshotImage2
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage2.width
                    duration: 10000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage2.width
                    to: 0
                    duration: 10000
                }
            }
        }

        // Efecto CRT (ShaderEffect)
        ShaderEffect {
            id: crtEffect
            anchors.fill: parent
            opacity: screensaverActive ? 1 : 0 // Semi-transparente cuando el screensaver está activo
            visible: screensaverActive // Solo visible cuando el screensaver está activo

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            // Propiedades del shader
            property real time: 0 // Puedes animar esto para un efecto más dinámico
            property variant source: null // No necesitamos una fuente, ya que es un efecto de superposición

            // Vertex shader (no necesario modificarlo para este efecto)
            vertexShader: "
            uniform highp mat4 qt_Matrix;
            attribute highp vec4 qt_Vertex;
            attribute highp vec2 qt_MultiTexCoord0;
            varying highp vec2 coord;
            void main() {
            coord = qt_MultiTexCoord0;
            gl_Position = qt_Matrix * qt_Vertex;
        }"

        // Fragment shader para el efecto de scanlines
        fragmentShader: "
        varying highp vec2 coord;
        uniform lowp float qt_Opacity;
        void main() {
        // Efecto de líneas de escaneo (scanlines)
        highp float scanline = mod(coord.y * 400.0, 2.0);
        scanline = clamp(scanline, 0.5, 1.0); // Hacemos las líneas semi-transparentes

        // Color final con el efecto de scanlines
        gl_FragColor = vec4(0.0, 0.0, 0.0, (1.0 - scanline) * 0.5) * qt_Opacity;
        }"
        }

        // Logo del juego
        Image {
            id: gameLogo1
            width: parent.width * 0.5
            height: width * 0.5
            anchors {
                right: parent.right
                bottom: parent.bottom
                margins: 20
            }
            fillMode: Image.PreserveAspectFit
            opacity: screensaverActive ? 1 : 0
            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }
        }
    }*/


    /*Rectangle {
        id: imagesScreenshots
        color: "transparent"
        width: parent.width
        height: parent.height
        z: 1001

        // Propiedad para controlar la intensidad del Glow
        property real glowIntensity: 0.3 // Valor entre 0 y 1

        // Imágenes del screensaver
        Image {
            id: screenshotImage1
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage1.width
                    duration: 5000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage1.width
                    to: 0
                    duration: 5000
                }
            }

            // Efecto Glow para screenshotImage1
            ShaderEffect {
                id: glowEffect1
                anchors.fill: parent
                opacity: screensaverActive ? 1 : 0 // Visible cuando el screensaver está activo
                visible: screensaverActive && showImage1 // Solo visible si es la imagen actual

                // Propiedades del shader
                property variant source: parent // Usamos la imagen padre como fuente
                property real glowIntensity: imagesScreenshots.glowIntensity // Intensidad del Glow

                // Vertex shader (no necesario modificarlo para este efecto)
                vertexShader: "
                uniform highp mat4 qt_Matrix;
                attribute highp vec4 qt_Vertex;
                attribute highp vec2 qt_MultiTexCoord0;
                varying highp vec2 coord;
                void main() {
                coord = qt_MultiTexCoord0;
                gl_Position = qt_Matrix * qt_Vertex;
            }"

            // Fragment shader para el efecto de scanlines, desenfoque gaussiano y Glow
            fragmentShader: "
            varying highp vec2 coord;
            uniform lowp float qt_Opacity;
            uniform lowp float glowIntensity;
            uniform sampler2D source;

            // Función para calcular el brillo de un color
            highp float luminance(highp vec3 color) {
            return dot(color, vec3(0.2126, 0.7152, 0.0722));
            }

            // Función para aplicar un desenfoque gaussiano simple
            highp vec4 blur(highp vec2 uv) {
            highp vec2 texelSize = vec2(1.0 / 800.0, 1.0 / 600.0); // Ajusta según la resolución
            highp vec4 color = vec4(0.0);
            highp float totalWeight = 0.0;

            for (int x = -2; x <= 2; x++) {
                for (int y = -2; y <= 2; y++) {
                    highp float weight = exp(-float(x * x + y * y) / 2.0);
                    color += texture2D(source, uv + vec2(x, y) * texelSize) * weight;
                    totalWeight += weight;
            }
            }

            return color / totalWeight;
            }

            void main() {
            // Obtener el color de la imagen original
            highp vec4 originalColor = texture2D(source, coord);

            // Efecto de líneas de escaneo (scanlines)
            highp float scanline = mod(coord.y * 400.0, 2.0);
            scanline = clamp(scanline, 0.5, 1.0); // Hacemos las líneas semi-transparentes

            // Aplicar el efecto de scanlines al color original
            highp vec4 crtColor = originalColor * scanline;

            // Aplicar el efecto Glow con desenfoque gaussiano
            highp vec4 blurredColor = blur(coord);
            highp float brightness = luminance(originalColor.rgb);
            highp vec4 glowColor = blurredColor * brightness * glowIntensity * 2.0; // Aumentamos la intensidad

            // Combinar el efecto CRT con el Glow
            highp vec4 finalColor = crtColor + glowColor;

            // Ajustar la opacidad final
            gl_FragColor = finalColor * qt_Opacity;
            }"
            }
        }

        Image {
            id: screenshotImage2
            width: parent.width * 1.05
            height: parent.height * 1.05
            opacity: 0
            fillMode: Image.Stretch
            scale: 1.2

            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }

            SequentialAnimation on x {
                loops: Animation.Infinite
                PropertyAnimation {
                    from: 0
                    to: parent.width - screenshotImage2.width
                    duration: 10000
                }
                PropertyAnimation {
                    from: parent.width - screenshotImage2.width
                    to: 0
                    duration: 10000
                }
            }

            // Efecto Glow para screenshotImage2
            ShaderEffect {
                id: glowEffect2
                anchors.fill: parent
                opacity: screensaverActive ? 1 : 0 // Visible cuando el screensaver está activo
                visible: screensaverActive && !showImage1 // Solo visible si es la imagen actual

                // Propiedades del shader
                property variant source: parent // Usamos la imagen padre como fuente
                property real glowIntensity: imagesScreenshots.glowIntensity // Intensidad del Glow

                // Vertex shader (no necesario modificarlo para este efecto)
                vertexShader: "
                uniform highp mat4 qt_Matrix;
                attribute highp vec4 qt_Vertex;
                attribute highp vec2 qt_MultiTexCoord0;
                varying highp vec2 coord;
                void main() {
                coord = qt_MultiTexCoord0;
                gl_Position = qt_Matrix * qt_Vertex;
            }"

            // Fragment shader para el efecto de scanlines, desenfoque gaussiano y Glow
            fragmentShader: "
            varying highp vec2 coord;
            uniform lowp float qt_Opacity;
            uniform lowp float glowIntensity;
            uniform sampler2D source;

            // Función para calcular el brillo de un color
            highp float luminance(highp vec3 color) {
            return dot(color, vec3(0.2126, 0.7152, 0.0722));
            }

            // Función para aplicar un desenfoque gaussiano simple
            highp vec4 blur(highp vec2 uv) {
            highp vec2 texelSize = vec2(1.0 / 800.0, 1.0 / 600.0); // Ajusta según la resolución
            highp vec4 color = vec4(0.0);
            highp float totalWeight = 0.0;

            for (int x = -2; x <= 2; x++) {
                for (int y = -2; y <= 2; y++) {
                    highp float weight = exp(-float(x * x + y * y) / 2.0);
                    color += texture2D(source, uv + vec2(x, y) * texelSize) * weight;
                    totalWeight += weight;
            }
            }

            return color / totalWeight;
            }

            void main() {
            // Obtener el color de la imagen original
            highp vec4 originalColor = texture2D(source, coord);

            // Efecto de líneas de escaneo (scanlines)
            highp float scanline = mod(coord.y * 400.0, 2.0);
            scanline = clamp(scanline, 0.5, 1.0); // Hacemos las líneas semi-transparentes

            // Aplicar el efecto de scanlines al color original
            highp vec4 crtColor = originalColor * scanline;

            // Aplicar el efecto Glow con desenfoque gaussiano
            highp vec4 blurredColor = blur(coord);
            highp float brightness = luminance(originalColor.rgb);
            highp vec4 glowColor = blurredColor * brightness * glowIntensity * 2.0; // Aumentamos la intensidad

            // Combinar el efecto CRT con el Glow
            highp vec4 finalColor = crtColor + glowColor;

            // Ajustar la opacidad final
            gl_FragColor = finalColor * qt_Opacity;
            }"
            }
        }

        // Logo del juego
        Image {
            id: gameLogo1
            width: parent.width * 0.5
            height: width * 0.5
            anchors {
                right: parent.right
                bottom: parent.bottom
                margins: 20
            }
            fillMode: Image.PreserveAspectFit
            opacity: screensaverActive ? 1 : 0
            Behavior on opacity {
                NumberAnimation { duration: 1000 }
            }
        }
    }*/
